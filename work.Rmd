---
title: "work"
output: pdf_document
date: "2026-01-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  dev = "ragg_png",
  dpi = 300,
  fig.width = 6,
  fig.height = 4
)
```

```{r}
rm(list = ls())
setwd("/cloud/project/")
# renv::activate()
library(terra)
library(ncdf4)
library(maps)
library(climetrics)
library(vars)
```

## Correcting Spatial Resolution 
```{r}
# Let's focus on Canada
# Focusing on a region will reduce the time required for running the code
domain <- c(219.0, 307.4, 41.7, 83.1) # Canada

# Fractional Area Burned
data <- terra::rast("data/fractionBurnt_ESACCI-L4_FIRE-BA-MODIS-fv5.1.nc")
data <- crop(x = data, y = domain)
data <- subset(data, 1:180) # Subset Jan 2001 to Dec 2015
data <- aggregate(x = data, fact=2, fun="mean") # More coarse spatial resolution #remove to get better resolution*
crs(data) <- "EPSG:4326" # assign a map projection (WGS84)
fab <- data
mask <- mean(data) # create mask
mask <- mask - mask + 1 # make boolean mask
rm(data)

# Precipitation (m)
data_pr <- terra::rast("data/ERA5_pr_2001-2023.nc")
data_pr <- crop(x = data_pr, y = domain)
data_pr <- data_pr[[1:180]] # Subset Jan 2001 to Dec 2015
data_pr <- aggregate(x = data_pr, fact=2, fun="mean")
data_pr <- resample(data_pr, mask, method="bilinear") # Project/Resample 'pr' to match the exact grid of 'fab'
crs(data_pr) <- "EPSG:4326"
data_pr <- data_pr * mask # exclude gridcells that both data sets do not have in common
pr <- data_pr * 1000 # convert unit from m to mm
rm(data_pr)

# Near-surface temperature (K)
data_tas <- terra::rast("data/ERA5_tas_2001-2023.nc")
data_tas <- crop(x = data_tas, y = domain)
data_tas <- data_tas[[1:180]] # Subset Jan 2001 to Dec 2015
data_tas <- aggregate(x = data_tas, fact=2, fun="mean")
data_tas <- resample(data_tas, mask, method="bilinear") # Project/Resample 'tas' to match the exact grid of 'fab'
crs(data_tas) <- "EPSG:4326"
data_tas <- data_tas * mask # exclude gridcells that both data sets do not have in common
tas <- data_tas 
rm(data_tas)

# Soil Moisture ()
data_sm <- terra::rast("data/data_soil_moisture.nc")
data_sm <- crop(x = data_sm, y = domain)
data_sm <- data_sm[[1:180]] # Subset Jan 2001 to Dec 2015
data_sm <- aggregate(x = data_sm, fact=2, fun="mean")
data_sm <- resample(data_sm, mask, method="bilinear") # Project/Resample 'sm' to match the exact grid of 'fab'
crs(data_sm) <- "EPSG:4326"
data_sm <- data_sm * mask # exclude gridcells that both data sets do not have in common
sm <- data_sm 
rm(data_sm)

# Surface Wind ()
data_ws <- terra::rast("data/data_wind.nc")
data_ws <- crop(x = data_ws, y = domain)
data_ws <- data_ws[[1:180]] # Subset Jan 2001 to Dec 2015
data_ws <- aggregate(x = data_ws, fact=2, fun="mean")
data_ws <- resample(data_ws, mask, method="bilinear") # Project/Resample 'ws' to match the exact grid of 'fab'
crs(data_ws) <- "EPSG:4326"
data_ws <- data_ws * mask # exclude gridcells that both data sets do not have in common
ws <- data_ws 
rm(data_ws)

# Relative Humidity
data_rh <- terra::rast("data/relativeHumidity.nc")
data_rh <- aggregate(x = data_rh, fact=2, fun="mean")
data_rh <- resample(data_rh, mask, method="bilinear") # Project/Resample 'rh' to match the exact grid of 'fab'
crs(data_rh) <- "EPSG:4326"
data_rh <- data_rh * mask # exclude gridcells that both data sets do not have in common
rh <- data_rh 
rm(data_rh)
```

## Precipitation (m) 
```{r}
# 12-month climatological means
data <- pr

# Create a sequence of dates
start_date <- as.Date("2001-01-15")
end_date <- as.Date("2015-12-15")
dates <- seq(from = start_date, to = end_date, by = "month")

# Create raster time series
data.ts <- rts(data, dates)

# Calculate 12-month climatological means
data.12 <- apply.months(data.ts,'mean')

# Plot 12 months of data
my.col <- rev(map.pal("magma", n = 100))
plot(data.12, col = my.col)

# Calculate anomalies
# Get the number of years
n <- length(dates)/12

# Create a time series where the 12-month climatological mean repeats for all years 
data.clim <- rep(data.12, n)

# Calculate anomalies
data.anom <- data - data.clim

# Have a look at the data
my.col <- rev(map.pal("magma", n = 100))
plot(subset(data.anom, 1:1), col = my.col)
map("world2", add = TRUE)

# Detrend precipitation anomalies
# Define a function that removes a linear trend
detrend.fun <- function(x) {
  time <- 1:length(x)
  # If a grid cell contains NA, then set the result to NA
  if (is.na(mean(x))) {
    return(rep(NA, length(time)))
  } else {
    time <- 1:length(x)
    linear.model <- lm(x ~ time)
    detrended.series <- stats::residuals(linear.model)
    return(detrended.series)
  }
}

data.anom.detrend <- app(x = data.anom, fun = detrend.fun)
pr.anom.detrend <- data.anom.detrend

# Have a look at the data
my.col <- rev(map.pal("magma", n = 100))
plot(subset(data.anom.detrend, 1:1), col = my.col)
map("world2", add = TRUE)
```

## Near-surface air temperature
```{r}
# 12-month climatological means
data <- tas

# Create a sequence of dates
start_date <- as.Date("2001-01-15")
end_date <- as.Date("2015-12-15")
dates <- seq(from = start_date, to = end_date, by = "month")

# Create raster time series
data.ts <- rts(data, dates)

# Calculate 12-month climatological means
data.12 <- apply.months(data.ts,'mean')

# Plot 12 months of data
my.col <- rev(map.pal("magma", n = 100))
plot(data.12, col = my.col)

# Calculate anomalies
# Get the number of years
n <- length(dates)/12

# Create a time series where the 12-month climatological mean repeats for all years 
data.clim <- rep(data.12, n)

# Calculate anomalies
data.anom <- data - data.clim

# Have a look at the data
my.col <- rev(map.pal("magma", n = 100))
plot(subset(data.anom, 1:1), col = my.col)
map("world2", add = TRUE)

# Detrend Temperature anomalies
# Define a function that removes a linear trend
detrend.fun <- function(x) {
  time <- 1:length(x)
  # If a grid cell contains NA, then set the result to NA
  if (is.na(mean(x))) {
    return(rep(NA, length(time)))
  } else {
    time <- 1:length(x)
    linear.model <- lm(x ~ time)
    detrended.series <- stats::residuals(linear.model)
    return(detrended.series)
  }
}

data.anom.detrend <- app(x = data.anom, fun = detrend.fun)
tas.anom.detrend <- data.anom.detrend

# Have a look at the data
my.col <- rev(map.pal("magma", n = 100))
plot(subset(data.anom.detrend, 1:1), col = my.col)
map("world2", add = TRUE)
```


## Soil Moisture
```{r}
# 12-month climatological means
data <- sm

# Create a sequence of dates
start_date <- as.Date("2001-01-15")
end_date <- as.Date("2015-12-15")
dates <- seq(from = start_date, to = end_date, by = "month")

# Create raster time series
data.ts <- rts(data, dates)

# Calculate 12-month climatological means
data.12 <- apply.months(data.ts,'mean')

# Plot 12 months of data
my.col <- rev(map.pal("magma", n = 100))
plot(data.12, col = my.col)

# Calculate anomalies
# Get the number of years
n <- length(dates)/12

# Create a time series where the 12-month climatological mean repeats for all years 
data.clim <- rep(data.12, n)

# Calculate anomalies
data.anom <- data - data.clim

# Have a look at the data
my.col <- rev(map.pal("magma", n = 100))
plot(subset(data.anom, 1:1), col = my.col)
map("world2", add = TRUE)

# Detrend precipitation anomalies
# Define a function that removes a linear trend
detrend.fun <- function(x) {
  time <- 1:length(x)
  # If a grid cell contains NA, then set the result to NA
  if (is.na(mean(x))) {
    return(rep(NA, length(time)))
  } else {
    time <- 1:length(x)
    linear.model <- lm(x ~ time)
    detrended.series <- stats::residuals(linear.model)
    return(detrended.series)
  }
}

data.anom.detrend <- app(x = data.anom, fun = detrend.fun)
sm.anom.detrend <- data.anom.detrend

# Have a look at the data
my.col <- rev(map.pal("magma", n = 100))
plot(subset(data.anom.detrend, 1:1), col = my.col)
map("world2", add = TRUE)
```

## Surface Wind
```{r}
# 12-month climatological means
data <- ws

# Create a sequence of dates
start_date <- as.Date("2001-01-15")
end_date <- as.Date("2015-12-15")
dates <- seq(from = start_date, to = end_date, by = "month")

# Create raster time series
data.ts <- rts(data, dates)

# Calculate 12-month climatological means
data.12 <- apply.months(data.ts,'mean')

# Plot 12 months of data
my.col <- rev(map.pal("magma", n = 100))
plot(data.12, col = my.col)

# Calculate anomalies
# Get the number of years
n <- length(dates)/12

# Create a time series where the 12-month climatological mean repeats for all years 
data.clim <- rep(data.12, n)

# Calculate anomalies
data.anom <- data - data.clim

# Have a look at the data
my.col <- rev(map.pal("magma", n = 100))
plot(subset(data.anom, 1:1), col = my.col)
map("world2", add = TRUE)

# Detrend precipitation anomalies
# Define a function that removes a linear trend
detrend.fun <- function(x) {
  time <- 1:length(x)
  # If a grid cell contains NA, then set the result to NA
  if (is.na(mean(x))) {
    return(rep(NA, length(time)))
  } else {
    time <- 1:length(x)
    linear.model <- lm(x ~ time)
    detrended.series <- stats::residuals(linear.model)
    return(detrended.series)
  }
}

data.anom.detrend <- app(x = data.anom, fun = detrend.fun)
ws.anom.detrend <- data.anom.detrend

# Have a look at the data
my.col <- rev(map.pal("magma", n = 100))
plot(subset(data.anom.detrend, 1:1), col = my.col)
map("world2", add = TRUE)
```
## Relative Humidity
```{r}
# 12-month climatological means
data <- rh

# Create a sequence of dates
start_date <- as.Date("2001-01-15")
end_date <- as.Date("2015-12-15")
dates <- seq(from = start_date, to = end_date, by = "month")

# Create raster time series
data.ts <- rts(data, dates)

# Calculate 12-month climatological means
data.12 <- apply.months(data.ts,'mean')

# Plot 12 months of data
my.col <- rev(map.pal("magma", n = 100))
plot(data.12, col = my.col)

# Calculate anomalies
# Get the number of years
n <- length(dates)/12

# Create a time series where the 12-month climatological mean repeats for all years 
data.clim <- rep(data.12, n)

# Calculate anomalies
data.anom <- data - data.clim

# Have a look at the data
my.col <- rev(map.pal("magma", n = 100))
plot(subset(data.anom, 1:1), col = my.col)
map("world2", add = TRUE)

# Detrend precipitation anomalies
# Define a function that removes a linear trend
detrend.fun <- function(x) {
  time <- 1:length(x)
  # If a grid cell contains NA, then set the result to NA
  if (is.na(mean(x))) {
    return(rep(NA, length(time)))
  } else {
    time <- 1:length(x)
    linear.model <- lm(x ~ time)
    detrended.series <- stats::residuals(linear.model)
    return(detrended.series)
  }
}

data.anom.detrend <- app(x = data.anom, fun = detrend.fun)
rh.anom.detrend <- data.anom.detrend

# Have a look at the data
my.col <- rev(map.pal("magma", n = 100))
plot(subset(data.anom.detrend, 1:1), col = my.col)
map("world2", add = TRUE)
```

## FAB
```{r}
# 12-month climatological means
data <- fab

# Create a sequence of dates
start_date <- as.Date("2001-01-15")
end_date <- as.Date("2015-12-15")
dates <- seq(from = start_date, to = end_date, by = "month")

# Create raster time series
data.ts <- rts(data, dates)

# Calculate 12-month climatological means
data.12 <- apply.months(data.ts,'mean')

# Plot 12 months of data
my.col <- rev(map.pal("magma", n = 100))
plot(data.12, col = my.col)

# Calculate anomalies
# Get the number of years
n <- length(dates)/12

# Create a time series where the 12-month climatological mean repeats for all years 
data.clim <- rep(data.12, n)

# Calculate anomalies
data.anom <- data - data.clim

# Have a look at the data
my.col <- rev(map.pal("magma", n = 100))
plot(subset(data.anom, 1:1), col = my.col)
map("world2", add = TRUE)

# Detrend precipitation anomalies
# Define a function that removes a linear trend
detrend.fun <- function(x) {
  time <- 1:length(x)
  # If a grid cell contains NA, then set the result to NA
  if (is.na(mean(x))) {
    return(rep(NA, length(time)))
  } else {
    time <- 1:length(x)
    linear.model <- lm(x ~ time)
    detrended.series <- stats::residuals(linear.model)
    return(detrended.series)
  }
}

data.anom.detrend <- app(x = data.anom, fun = detrend.fun)
fab.anom.detrend <- data.anom.detrend

# Have a look at the data
my.col <- rev(map.pal("magma", n = 100))
plot(subset(data.anom.detrend, 1:1), col = my.col)
map("world2", add = TRUE)
```

# Causal Inference

### Defining a Granger causality function that can be applied to each grid cell
```{r}
granger.fun <- function(x) {

  # Always return numeric(1)
  
  # If all NA → return NA_real_
  if (all(is.na(x))) return(NA_real_)

  n <- length(x)

  # Must be even length
  if (n %% 2 != 0) return(NA_real_)

  a <- x[1:(n/2)]
  b <- x[(n/2 + 1):n]

  # If any NA present → return NA
  if (any(is.na(a)) || any(is.na(b))) return(NA_real_)

  tsDat <- cbind(a = a, b = b)

  # Try VAR safely
  tsVAR <- try(vars::VAR(tsDat, p = 2), silent = TRUE)
  if (inherits(tsVAR, "try-error")) return(NA_real_)

  gr <- try(vars::causality(tsVAR, cause = "a"), silent = TRUE)
  if (inherits(gr, "try-error")) return(NA_real_)

  pval <- gr$Granger$p.value

  # If p-value missing or invalid
  if (is.null(pval) || length(pval) != 1 || !is.numeric(pval)) {
    return(NA_real_)
  }

  return(as.numeric(pval))
}
```


## Check whether precipitation Granger-causes FAB anomalies
```{r}
# Stack your raster objects, where the first part is the cause and the second the response
data <- c(pr.anom.detrend, fab.anom.detrend)

# Assess Granger causality
p.value <- app(x = data, fun = granger.fun)

# Create a boolean map where all locations with p-values < 0.01 equal 1 and all remaining gridcells equal zero
p.value[p.value >= 0.05] <- 0
p.value[p.value > 0] <- 1

p.value.pr <- p.value

plot(p.value, col = c("white", "orange"), main = "Precipitation Granger-causes FAB Anomalies")
map("world2", add = TRUE, interior = FALSE)
```


## Check whether Temperature Granger-causes FAB anomalies
```{r}
# Stack your raster objects, where the first part is the cause and the second the response
data <- c(tas.anom.detrend, fab.anom.detrend)

# Assess Granger causality
p.value <- app(x = data, fun = granger.fun)

# Create a boolean map where all locations with p-values < 0.01 equal 1 and all remaining gridcells equal zero
p.value[p.value >= 0.05] <- 0
p.value[p.value > 0] <- 1

p.value.tas <- p.value

plot(p.value, col = c("white", "orange"), main = "Temperature Granger-causes FAB Anomalies")
map("world2", add = TRUE, interior = FALSE)
```

## Check whether Soil moisture Granger-causes FAB anomalies
```{r}
# Stack your raster objects, where the first part is the cause and the second the response
data <- c(sm.anom.detrend, fab.anom.detrend)

# Assess Granger causality
p.value <- app(x = data, fun = granger.fun)

# Create a boolean map where all locations with p-values < 0.01 equal 1 and all remaining gridcells equal zero
p.value[p.value >= 0.05] <- 0
p.value[p.value > 0] <- 1

p.value.sm <- p.value

plot(p.value, col = c("white", "orange"), main = "Soil Moisture Granger-causes FAB Anomalies")
map("world2", add = TRUE, interior = FALSE)
```


## Check whether Wind Speed Granger-causes FAB anomalies
```{r}
# Stack your raster objects, where the first part is the cause and the second the response
data <- c(ws.anom.detrend, fab.anom.detrend)

# Assess Granger causality
p.value <- app(x = data, fun = granger.fun)

# Create a boolean map where all locations with p-values < 0.01 equal 1 and all remaining gridcells equal zero
p.value[p.value >= 0.05] <- 0
p.value[p.value > 0] <- 1

p.value.ws <- p.value

plot(p.value, col = c("white", "orange"), main = "Wind Speed Granger-causes FAB Anomalies")
map("world2", add = TRUE, interior = FALSE)
```

## Check whether Relative Humidity Granger-causes FAB anomalies
```{r}
# Stack your raster objects, where the first part is the cause and the second the response
data <- c(rh.anom.detrend, fab.anom.detrend)

# Assess Granger causality
p.value <- app(x = data, fun = granger.fun)

# Create a boolean map where all locations with p-values < 0.01 equal 1 and all remaining gridcells equal zero
p.value[p.value >= 0.05] <- 0
p.value[p.value > 0] <- 1

p.value.rh <- p.value

plot(p.value, col = c("white", "orange"), main = "Relative Humidity Granger-causes FAB Anomalies")
map("world2", add = TRUE, interior = FALSE)
```

## Identify gridcells where all five variables granger-cause FAB
```{r}
p.value <- p.value.pr + p.value.tas + p.value.sm + p.value.ws + p.value.rh

my_colors <- c("white", "#580072", "#576880", "#2aa6b8", "#2ecc71")

plot(p.value, col= my_colors, main = "PR, TAS, SM, WS and RH Granger-causes FAB Anomalies" 
     )
map("world2", add = TRUE, interior = FALSE)
```

## Cross correlation

# Define a function that finds the time lag with the largest correlation coefficient
# define a function that gives the corresponding correlation coefficient

```{r}
findLag.fun <- function(x) {
  # 1. Strict NA check
  if (any(is.na(x))) return(NA)
  
  n <- length(x)
  mid <- n / 2
  a <- x[1:mid]
  b <- x[(mid + 1):n]
  
  # 2. Check for zero variance (if all values are the same, correlation is impossible)
  if (var(a) == 0 || var(b) == 0) return(NA)
  
  # 3. Secure the calculation
  res <- tryCatch({
    ccf_result <- ccf(a, b, lag.max = 12, plot = FALSE)
    max_index <- which.max(abs(ccf_result$acf))
    as.numeric(ccf_result$lag[max_index])
  }, error = function(e) return(NA))
  
  return(res)
}

findMaxCorr.fun <- function(x) {
  if (any(is.na(x))) return(NA)
  
  n <- length(x)
  mid <- n / 2
  a <- x[1:mid]
  b <- x[(mid + 1):n]
  
  if (var(a) == 0 || var(b) == 0) return(NA)
  
  res <- tryCatch({
    ccf_result <- ccf(a, b, lag.max = 12, plot = FALSE)
    max_index <- which.max(abs(ccf_result$acf))
    as.numeric(ccf_result$acf[max_index])
  }, error = function(e) return(NA))
  
  return(res)
}
```

# precipitation 
```{r}
# Stack your raster objects, where the first part is the cause and the second the response
data <- c(fab.anom.detrend, pr.anom.detrend)

# Compute time lags with largest correlation coefficients
timeLags <- app(x = data, fun = findLag.fun)
maxCorr <- app(x = data, fun = findMaxCorr.fun)
maxCorr.pr <- maxCorr

p.value.pr[p.value.pr==0] <- NA

maxCorr.pr <- maxCorr.pr * p.value.pr
maxCorr <- maxCorr.pr

par(mfrow = c(1, 2))

# Plot time lags
breaks <- seq(-12, 12, 1)
my.col <- rev(map.pal("differences", n = length(breaks) - 1))

plot(
  timeLags * p.value.pr,
  main = "Monthly time lags with largest correlation coefficient \n (Precipitation and FAB)",
  cex.main = 0.7,
  col = my.col,
  breaks = breaks,
  type = "continuous"
)
map("world2", add = TRUE, interior = FALSE)

# Plot Correlation Coefficients
breaks <- seq(-1, 1, 0.1)
my.col <- rev(map.pal("differences", n = length(breaks) - 1))

plot(
  maxCorr,
  main = "Corresaponding Correlation coefficient \n (Precipitation and FAB)",
  cex.main = 0.7,
  col = my.col,
  breaks = breaks,
  type = "continuous"
)
map("world2", add = TRUE, interior = FALSE)

```

# Temperature
```{r}
# Stack your raster objects, where the first part is the cause and the second the response
data <- c(fab.anom.detrend, tas.anom.detrend)

# Compute time lags with largest correlation coefficients
timeLags <- app(x = data, fun = findLag.fun)
maxCorr <- app(x = data, fun = findMaxCorr.fun)
maxCorr.tas <- maxCorr

p.value.tas[p.value.tas==0] <- NA

maxCorr.tas <- maxCorr.tas * p.value.tas
maxCorr <- maxCorr.tas

par(mfrow = c(1, 2))

# Plot time lags
breaks <- seq(-12, 12, 1)
my.col <- rev(map.pal("differences", n = length(breaks) - 1))

plot(
  timeLags * p.value.tas,
  main = "Monthly time lags with largest correlation coefficient \n (Temperature and FAB)",
  cex.main = 0.7,
  col = my.col,
  breaks = breaks,
  type = "continuous"
)
map("world2", add = TRUE, interior = FALSE)

# Plot Correlation Coefficients
breaks <- seq(-1, 1, 0.1)
my.col <- rev(map.pal("differences", n = length(breaks) - 1))

plot(
  maxCorr,
  main = "Corresaponding Correlation coefficient \n (Temperature and FAB)",
  cex.main = 0.7,
  col = my.col,
  breaks = breaks,
  type = "continuous"
)
map("world2", add = TRUE, interior = FALSE)

```

# soil Moisture
```{r}
# Stack your raster objects, where the first part is the cause and the second the response
data <- c(fab.anom.detrend, sm.anom.detrend)

# Compute time lags with largest correlation coefficients
timeLags <- app(x = data, fun = findLag.fun)
maxCorr <- app(x = data, fun = findMaxCorr.fun)
maxCorr.sm <- maxCorr

p.value.sm[p.value.sm==0] <- NA

maxCorr.sm <- maxCorr.sm * p.value.sm
maxCorr <- maxCorr.sm

par(mfrow = c(1, 2))

# Plot time lags
breaks <- seq(-12, 12, 1)
my.col <- rev(map.pal("differences", n = length(breaks) - 1))

plot(
  timeLags * p.value.sm,
  main = "Monthly time lags with largest correlation coefficient \n (Soil Moisture and FAB)",
  cex.main = 0.7,
  col = my.col,
  breaks = breaks,
  type = "continuous"
)
map("world2", add = TRUE, interior = FALSE)

# Plot Correlation Coefficients
breaks <- seq(-1, 1, 0.1)
my.col <- rev(map.pal("differences", n = length(breaks) - 1))

plot(
  maxCorr,
  main = "Corresaponding Correlation coefficient \n (Soil moisture and FAB)",
  cex.main = 0.7,
  col = my.col,
  breaks = breaks,
  type = "continuous"
)
map("world2", add = TRUE, interior = FALSE)

```

# Surface wind
```{r}
# Stack your raster objects, where the first part is the cause and the second the response
data <- c(fab.anom.detrend, ws.anom.detrend)

# Compute time lags with largest correlation coefficients
timeLags <- app(x = data, fun = findLag.fun)
maxCorr <- app(x = data, fun = findMaxCorr.fun)
maxCorr.ws <- maxCorr

p.value.ws[p.value.ws==0] <- NA

maxCorr.ws <- maxCorr.ws * p.value.ws
maxCorr <- maxCorr.ws

par(mfrow = c(1, 2))

# Plot time lags
breaks <- seq(-12, 12, 1)
my.col <- rev(map.pal("differences", n = length(breaks) - 1))

plot(
  timeLags * p.value.ws,
  main = "Monthly time lags with largest correlation coefficient \n (Surface Winds and FAB)",
  cex.main = 0.7,
  col = my.col,
  breaks = breaks,
  type = "continuous"
)
map("world2", add = TRUE, interior = FALSE)

# Plot Correlation Coefficients
breaks <- seq(-1, 1, 0.1)
my.col <- rev(map.pal("differences", n = length(breaks) - 1))

plot(
  maxCorr,
  main = "Corresaponding Correlation coefficient \n (Surface Winds and FAB)",
  cex.main = 0.7,
  col = my.col,
  breaks = breaks,
  type = "continuous"
)
map("world2", add = TRUE, interior = FALSE)

```

# Relative Humidity
```{r}
# Stack your raster objects, where the first part is the cause and the second the response
data <- c(fab.anom.detrend, rh.anom.detrend)

# Compute time lags with largest correlation coefficients
timeLags <- app(x = data, fun = findLag.fun)
maxCorr <- app(x = data, fun = findMaxCorr.fun)
maxCorr.rh <- maxCorr

p.value.rh[p.value.rh==0] <- NA

maxCorr.rh <- maxCorr.rh * p.value.rh
maxCorr <- maxCorr.rh

par(mfrow = c(1, 2))

# Plot time lags
breaks <- seq(-12, 12, 1)
my.col <- rev(map.pal("differences", n = length(breaks) - 1))

plot(
  timeLags * p.value.rh,
  main = "Monthly time lags with largest correlation coefficient \n (Relative Humidity and FAB)",
  cex.main = 0.7,
  col = my.col,
  breaks = breaks,
  type = "continuous"
)
map("world2", add = TRUE, interior = FALSE)

# Plot Correlation Coefficients
breaks <- seq(-1, 1, 0.1)
my.col <- rev(map.pal("differences", n = length(breaks) - 1))

plot(
  maxCorr,
  main = "Corresaponding Correlation coefficient \n (Relative Humidity and FAB)",
  cex.main = 0.7,
  col = my.col,
  breaks = breaks,
  type = "continuous"
)
map("world2", add = TRUE, interior = FALSE)

```
```{r}
maxR2.pr <- maxCorr.pr^2 * p.value.pr
maxR2.tas <- maxCorr.tas^2 * p.value.tas
maxR2.sm <- maxCorr.sm^2 * p.value.sm
maxR2.ws <- maxCorr.ws^2 * p.value.ws
maxR2.rh <- maxCorr.rh^2 * p.value.rh

maxR2.pr[maxR2.pr==0] <- NA
maxR2.tas[maxR2.tas==0] <- NA
maxR2.sm[maxR2.sm==0] <- NA
maxR2.ws[maxR2.ws==0] <- NA
maxR2.rh[maxR2.rh==0] <- NA

stacked_rasters <- c(maxR2.pr, maxR2.tas, maxR2.sm, maxR2.ws, maxR2.rh)
names(stacked_rasters) <- c("PR", "TAS", "SM", "WS", "RH")

mask <- app(stacked_rasters, max, na.rm = TRUE)
mask <- mask - mask + 1

# Apply a function to find the index of the max value for each cell
highest_index <- app(stacked_rasters, which.max, na.rm = TRUE)

# Set the levels to replace numeric values with the names of the rasters
levels(highest_index) <- data.frame(id = 1:5, name = names(stacked_rasters))

# Exclude gridcells that are NA:
highest_index <- highest_index * mask

# Plot the result to visualize the highest value index for each cell
plot(highest_index, main = "Met variables that dominate FAB anomaly variability")
map("world2", add = TRUE, interior = FALSE)
```


```{r}
# 1. Calculate the frequency of each category
freq_table <- freq(highest_index)

# 2. Define colors to match your plot (optional, but good for consistency)
# PR: blue, TAS: red, SM: brown, WS: green, RH: purple (example palette)
my_cols <- c("#580072", "#576880", "#2aa6b8", "#2ecc71", "#f7e341")

# 3. Create the Pie Chart
pie(freq_table$count, 
    labels = paste0(freq_table$label, " (", round(100 * freq_table$count/sum(freq_table$count), 1), "%)"),
    col = my_cols,
    main = "Dominant Met Drivers of FAB Anomalies")
  legend("topleft", 
         legend = c("PR", "TAS", "SM", "WS", "RH"), 
         col= c("#580072", "#576880", "#2aa6b8", "#2ecc71", "#f7e341"), 
         pch = c(16)
  )
```
